from brewparse import parse_program
from intbase import *
from element import Element

# Custom exception class to catch return values
class ReturnValue(Exception):
    def __init__(self, return_value, return_type):
        self.return_value = return_value
        self.return_type = return_type

NO_VALUE_DEFINED = object()     # This line is from ChatGPT: wanted a way to define my own version of 'None'


class Interpreter(InterpreterBase):
    program_vars = {}
    defined_functions = {}      # should map function name to list of func nodes (for overloading)
    defined_structs = {}

    INT_OPERATIONS = ['+', '-', '*', '/', 'neg']
    BOOL_OPERATIONS = ['!', '||', '&&']
    EQUALITY_COMPARISONS = ['==', '!=']
    INTEGER_COMPARISONS = ['<', '<=', '>', '>=']
    OVERLOADED_OPERATIONS = ['+']
    STRING_OPERATIONS = ['+']

    class BrewinStruct():        
        def __init__(self, interpreter, struct_node):
            self.interpreter = interpreter
            # Struct_node: has var_type = struct name
                # Need to find proper struct w/ fields and initialize
            self.struct_name = struct_node.dict['var_type']

            # Find proper struct to initialize
            if (self.struct_name not in interpreter.defined_structs):
                InterpreterBase.error(
                    ErrorType.TYPE_ERROR,
                    f"STRUCT \"{self.struct_name}\" not defined"
                )
            
            struct_to_initialize = interpreter.defined_structs[self.struct_name]

            # Create dictionary of struct field values
            self.struct_fields = {}

            for field in struct_to_initialize.dict['fields']:
                field_name = field.dict['name']
                field_type = field.dict['var_type']
                if (field_type not in ['int', 'bool', 'string']+ list(interpreter.defined_structs.keys())):
                    InterpreterBase.error(
                        ErrorType.TYPE_ERROR,
                        f"Cannot initialize struct field of type \"{field_type}\" b/c it doesn't exist"
                    )

                # TODO: don't allow duplicate field names
                self.struct_fields[field_name] = {'type':field_type, 'val':interpreter.default_values(field_type)}
            
        def get_field(self, field):
            if (field not in self.struct_fields):
                InterpreterBase.error(
                    ErrorType.NAME_ERROR,
                    f"Field { {field} }  not defined for STRUCT \"{self.struct_name}\" "
                )
            else:
                return self.struct_fields[field]
            
        def __str__(self):
            str_print = "\nStruct Type: " +  self.struct_name + "\n"
            for field in self.struct_fields:
                str_print += ("\t" + field + "\t\t")
                str_print += ("Type = " + self.struct_fields[field]['type'] + "\tValue = " + str(self.struct_fields[field]['val']) + "\n")
            return str_print
            
   
    def __init__(self, console_output=True, inp=None, trace_output=False):
        super().__init__(console_output, inp)   # call InterpreterBase's constructor
        self.trace_output = trace_output

    ''' ---- RUN PROGRAM ---- '''
    def run(self, program):
        self.defined_functions = {}
        self.defined_structs = {}
        ''' 
            program = array of strings containing program
            ast = AST generated by parser
            self.program_vars = map to hold variables + their values
        '''
        self.ast = parse_program(program)

        ''' ---- Find Main Node ---- '''
        # Check program validity
        if (self.ast.elem_type != 'program'):
            super().error(
                ErrorType.NAME_ERROR,
                "Initial element type is not 'program' "
            )

        allowable_types = ['int', 'string', 'bool', 'void']
        
        # Loop through all provided user-defined structs, add to dictionary of defined structs
        for struct in self.ast.dict['structs']:
            struct_name = struct.dict['name']
            allowable_types.append(struct_name)
            self.defined_structs[struct_name] = struct
        

        # Search through program functions to find the MAIN node
        main_node = NO_VALUE_DEFINED
        for func in self.ast.dict['functions']:
            # Loop through all provided functions, add to dictionary of defined functions
            func_name = func.dict['name']
            if func_name not in self.defined_functions:
                self.defined_functions[func_name] = []
            self.defined_functions[func_name].append(func)
            
            # Identify main_node to run aftter
            if (func.dict['name'] == 'main'):
                main_node = func

            # Check for valid return types and parameters
            for arg in func.dict['args']:
                arg_type = arg.dict['var_type']
                if (arg_type not in allowable_types) or arg_type == 'void':
                    super().error(
                        ErrorType.TYPE_ERROR,
                        f"Invalid type for argument \"{arg.dict['name']}\" of type { {arg_type} }"
                    )

            ret_type = func.dict['return_type']
            if (ret_type not in allowable_types):
                super().error(
                        ErrorType.TYPE_ERROR,
                        f"Invalid RETURN TYPE for function \"{func_name}\" of type { {ret_type} }"
                    )
        
        
        if (main_node is NO_VALUE_DEFINED):
            super().error(
                ErrorType.NAME_ERROR,
                "No MAIN node found in program"
            )
        
        # Run MAIN node
        return self.run_func(main_node, [])

    def check_builtin_funcs(self, func_node, scope_stack):
        node_dict = func_node.dict
        func_name = node_dict['name']

        ''' PRINT + INPTUTI + INPUTS handling'''
        # Separate handling for: PRINT, INPUTI
        if func_name == 'inputi':
            if (self.trace_output == True):
                print("\tCalling inputi function")
            if (len (node_dict['args']) > 1):
                super().error(
                    ErrorType.NAME_ERROR,
                    f"No inputi() function found that takes more than 1 parameter"
                )
            return self.inputi(node_dict['args'])
        
        if func_name == 'inputs':
            if (self.trace_output == True):
                print("\tCalling inputs function")
            if (len (node_dict['args']) > 1):
                super().error(
                    ErrorType.NAME_ERROR,
                    f"No inputs() function found that takes more than 1 parameter"
                )
            return self.inputs(node_dict['args'])
        
        if func_name == 'print':
            return self.printout(scope_stack, node_dict['args'])
        ''' END OF SEPARATE HANDLING '''

        return NO_VALUE_DEFINED


    ''' ---- HANDLE fcall ---- '''
    def run_fcall(self, func_node, calling_func_vars):
        # calling_func_vars = variables defined by the calling function (where the statement was)
        node_dict = func_node.dict
        func_name = node_dict['name']
        func_args = node_dict['args']   # arguments passed into the function call

        if (self.trace_output):
            if (func_args == []):
                print("** RUN FCALL -- NO args provided")
            else:
                print("** RUN FCALL")
                print("\tProvided arguments: ")
                for arg in func_args:
                    print("\t\t", arg)

        # Check if Print, Inputi, or Inputs
        builtin = self.check_builtin_funcs(func_node, calling_func_vars)
        if builtin is not NO_VALUE_DEFINED:
            return builtin
        

        # For all other function calls: 
        if (func_name not in self.defined_functions):
            super().error(
                ErrorType.NAME_ERROR,
                f"Function {func_name} was not found / defined ",
            )

        # Based on the provided number of arguments in the function call
            # Identify the correct (possibly overloaded) function definition to run
        func_to_run = NO_VALUE_DEFINED
        defined_funcs_found = self.defined_functions[func_name]
        for func in defined_funcs_found:
            args = func.dict['args']
            if len(func_args) == len ( args ):
                func_to_run = func

        if (func_to_run is NO_VALUE_DEFINED):
            # Wrong number of arguments for this function
            super().error(
                ErrorType.NAME_ERROR, 
                f"Function { {func_name} } with { len(func_args)} parameters was not found"
            )

        function_formal_params = func_to_run.dict['args']
        func_arg_values = []

        # Check that argument types match parameter type
        param_arg_zip = zip(function_formal_params, func_args)

        for param, arg in param_arg_zip:
            param_type = param.dict['var_type']

            arg_type = arg.elem_type

            #  If string, int, or boolean value
            if (arg_type == 'string' or arg_type == 'int' or arg_type == 'bool'):
                # Check that type matches
                if (param_type != arg_type):
                    # Coercion between int --> bool
                    if (param_type == 'bool' and arg_type == 'int'):
                        int_val = self.get_value(arg)
                        func_arg_values.append({'type':'bool', 'val':bool(int_val)})
                    else:
                        super().error(
                        ErrorType.TYPE_ERROR,
                        f"Cannot assign type { { arg_type} } to parameter \"{param.dict['name']}\" of type { {param_type} }"
                    )
                else:
                    func_arg_values.append({'type':arg_type, 'val':self.get_value(arg)})

            elif (arg_type == 'var'):
                other_var_val = self.get_variable_value(arg, calling_func_vars)
                other_var_type = other_var_val['type']
                if (other_var_type != param_type):
                    # Coercion between int --> bool
                    if (param_type == 'bool' and other_var_type == 'int'):
                        func_arg_values.append( {'type': 'bool','val':bool(other_var_val['val'])} )
                    else:
                        super().error(
                            ErrorType.TYPE_ERROR,
                            f"Cannot assign type { { other_var_type } } to PARAMETER \"{param.dict['name']}\" of type { {param_type} }"
                        )
                else:
                    # Add copy of variable value or obj ref if struct
                    func_arg_values.append( other_var_val )     # dictionary

            elif (arg_type == 'fcall'):
                fcall_ret = self.run_fcall( arg, calling_func_vars)
                if (fcall_ret['type'] != param_type):
                    if (param_type == 'bool' and fcall_ret['type'] == 'int'):
                        func_arg_values.append( {'type': 'bool', 'val': bool(fcall_ret['val'])} )
                    else:
                        super().error(
                            ErrorType.TYPE_ERROR,
                            f"Cannot assign type { { fcall_ret['type'] } } to PARAMETER \"{param.dict['name']}\" of type { {param_type} } via FUNCTION CALL RETURN VALUE"
                        )
                else:
                    func_arg_values.append( fcall_ret )

            
            elif (param_type == 'int'):
                func_arg_values.append( {'type':'int', 'val': self.int_types(arg, calling_func_vars)} )
            elif (param_type == 'string'):
                func_arg_values.append( {'type': 'string', 'val': self.string_types(arg, calling_func_vars)} )
            elif (param_type == 'bool'):
                func_arg_values.append( {'type':'bool', 'val': self.bool_types(arg, calling_func_vars)} )

            elif(arg_type == 'nil'):
                if (param_type not in self.defined_structs):
                    super().error(
                        ErrorType.TYPE_ERROR,
                        f"Attempted to pass in NIL argument as type { {param_type} } to function \"{func_name}\""
                    )
                func_arg_values.append({'type':'nil', 'val': Element("nil")})

            elif(arg_type == 'new'):
                # Create new STRUCT + pass in dictionary mapping type to the obj ref
                struct_type = arg.dict['var_type']
                struct_OR = self.BrewinStruct(self, arg)
                func_arg_values.append({'type':struct_type, 'val':struct_OR})

            else:
                # print("\n**** Out of argument options to check (just appending whole arg) \n")
                func_arg_values.append(arg)


        function_ret_val = self.run_func( func_to_run , func_arg_values )
        
        # If void function
        if (function_ret_val == None):
            return None
        
        return {'val': function_ret_val.return_value, 'type':function_ret_val.return_type}


    ''' ---- RUN FUNCTION ---- '''
    def run_func(self, func_node, func_args):
        # Should already be checked in run_fcall that function exists, but extra check just in case
        if (func_node.elem_type != 'func'):
            super().error(
                ErrorType.TYPE_ERROR,
                "Non-function node passed into run_func"
            )

        # Create dictionary to hold variables local to this function
        scope_stack = []
        func_vars = {}
        
        node_dict = func_node.dict
        node_params = node_dict['args']
        expected_return_type = node_dict['return_type']


        if (self.trace_output == True):
            if node_params == []:
                print("\tThis function has NO parameters")
            else:
                print("\tThis function has the following paramters: ")
                for arg in node_params:
                    print("\t\t", arg)

        # Map argument values to the parameter names
        for param, var_value in zip(node_params, func_args):
            var_name = param.dict['name']
            var_type = param.dict['var_type']

            func_vars[var_name] = {}
            func_vars[var_name]['type'] = var_type

            func_vars[var_name]['val'] = var_value['val']
            

        # Base parameter:argument pairs are the ENCLOSING environment defined variables
        scope_stack.append( func_vars )

        # Loop through function statements in order
        for statement_node in node_dict['statements']:
            # Run each statement
            try:
                self.run_statement(statement_node, scope_stack)
            # If RETURN is found, should throw an exception
            except ReturnValue as rval:
                # Remove all added scopes from inside function
                while (len(scope_stack) > 1):
                    scope_stack.pop()

                if (expected_return_type == 'void'):
                    if (rval.return_type != None or rval.return_value != None):
                        super().error(
                            ErrorType.TYPE_ERROR,
                            f"Attempted to return a value from a VOID function"
                        )
                    return
                
                if (rval.return_type == None and rval.return_value == None):
                    return_val = self.default_values(expected_return_type)
                    return ReturnValue(return_val, expected_return_type)
                
                if (rval.return_type == 'int' and expected_return_type == 'bool'):
                        return ReturnValue( bool(rval.return_value), expected_return_type )
                
                if rval.return_type != expected_return_type:
                    super().error(
                        ErrorType.TYPE_ERROR,
                        f"Returned value { {rval.return_value} } does not match expected type \"{expected_return_type}\" "
                    )
                return rval

        if expected_return_type == 'void':
            return None
        
        return_val = self.default_values(expected_return_type)
        return ReturnValue(return_val, expected_return_type)
    

    ''' ---- RUN STATEMENT ---- '''
    def run_statement(self, statement_node, func_vars):
        node_type = statement_node.elem_type

        # Run node's respective function
        match node_type:
            case 'vardef':
                if (self.trace_output == True):
                    print("\nRUN_STATEMENT: This node is a variable definition")
                self.run_vardef(statement_node, func_vars)
            case '=':
                if (self.trace_output == True):
                    print("\nRUN_STATEMENT: This node is a variable assignment")
                self.run_assign(statement_node, func_vars)
            case 'fcall':
                if (self.trace_output == True):
                    print("\nRUN_STATEMENT: This node is a function call")
                self.run_fcall(statement_node, func_vars)
            case 'if':
                if (self.trace_output == True):
                    print("\nRUN_STATEMENT: This node is an IF statement")
                self.evaluate_if(statement_node, func_vars)
            case 'for':
                if (self.trace_output == True):
                    print("\nRUN_STATEMENT: This node is an FOR loop")
                self.run_for_loop(statement_node, func_vars)
            case 'return':
                return_expression = statement_node.dict['expression']

                # print("\n--In RETURN statement handling in rUN_STATEMENT\n\tExpression to return: ", return_expression)

                return_val = None
                return_type = None

                if return_expression == None:
                    raise ReturnValue(None, None)

                if return_expression.elem_type == "nil":
                    return_val = Element("nil")
                else:
                    return_exp_type = return_expression.elem_type


                    # If returning a CONSTANT value
                    if (return_exp_type in ['int', 'string', 'bool']):
                        return_val = self.get_value(return_expression)
                        return_type = return_exp_type
                    
                    # If returning a VARIABLE value
                    elif (return_exp_type == 'var'):
                        return_val_all = self.get_variable_value(return_expression, func_vars)
                        return_val = return_val_all['val']
                        return_type = return_val_all['type']
                    
                    # If using an OVERLOADED OPERATOR 
                    elif (return_exp_type in self.OVERLOADED_OPERATIONS):
                        return_val = self.overloaded_operator(return_expression, func_vars)
                        if (type(return_val) == int):
                            return_type = 'int'
                        elif (type(return_val) == str):
                            return_type = 'string'
                    
                    # If returning an OPERATION
                    elif (return_exp_type in self.INT_OPERATIONS):
                        return_val = self.run_int_operation( return_expression, func_vars )
                        return_type = 'int'
                    
                    # If returning result of BOOLEAN operation
                    elif (return_exp_type in self.BOOL_OPERATIONS):
                        return_val = self.run_bool_operation( return_expression, func_vars )
                        return_type = 'bool'
                    
                    # If returning result of EQUALITY comparison operation
                    elif (return_exp_type in self.EQUALITY_COMPARISONS):
                        return_val = self.check_equality( return_expression, func_vars )
                        return_type = 'bool'
                    
                    # If returning result of INTEGER COMPARISON
                    elif (return_exp_type in self.INTEGER_COMPARISONS):
                        return_val = self.integer_compare( return_expression, func_vars )
                        return_type = 'bool'
                    
                    elif (return_exp_type == 'fcall'):
                        return_val_fcall = self.run_fcall( return_expression, func_vars )
                        return_val = return_val_fcall['val']
                        return_type = return_val_fcall['type']

                    # if (return_val == None):  
                    #     print("ERR: no return value set")

                raise ReturnValue(return_val, return_type)

            case _:
                super().error(
                    ErrorType.NAME_ERROR,
                    f"Unrecognized statement of type {node_type}"
                )

    def default_values(self, type):
        if (type == 'bool'):
            return False
        if (type == 'string'):
            return ""
        if (type == 'int'):
            return 0
        if (type in self.defined_structs):
            return Element("nil")


    ''' ---- Running Statement Types ---- '''
    # VARDEF
    def run_vardef(self, node, scope_stack):
        if (self.trace_output == True):
            print("\tInside RUN_VARDEF")
        var_name = node.dict['name']
        var_type = node.dict['var_type']


        # Retrieves top-most scope (within inner-most block)
        latest_scope = scope_stack[-1]

        # Check if variable has already been defined in this scope
        if var_name in latest_scope:
            super().error(
                ErrorType.NAME_ERROR,
                f"Variable {var_name} defined more than once"
            )

        var_dict = {}
        var_dict['type'] = var_type

        # If unrecognized type in definition --> type error
        if (var_type not in ['int', 'bool', 'string']+ list(self.defined_structs.keys())):
            super().error(
                ErrorType.TYPE_ERROR,
                f"Unrecognized type for variable definition: { {var_type} }"
            )
        
        # Add new variable to func_vars           Initial value: Default value, None if no default set (used for my checking)
        var_dict['val'] = self.default_values(var_type)

        latest_scope[var_name] = var_dict

        if (self.trace_output == True):
            print("\t\tCurrent func_vars: ", latest_scope)


    ''' ---- Variable Assignment ---- '''
    def run_assign(self, node, scope_stack):
        if (self.trace_output == True):
            print("\tInside RUN_ASSIGN")
        node_dict = node.dict
        var_name = node_dict['name']

        # print("\n-- In VAR ASSIGN\tNode = ", node)

        scope_to_update = NO_VALUE_DEFINED

        # If updating a struct field, refer to special struct_updating function
        if ('.' in var_name):
            self.struct_update(node, scope_stack)         
            return

        # Traverse stack in reverse order
        for scope in scope_stack[::-1]:
            # If variable exists in this scope, this is the one you want to update
            # ONLY EDIT TOPMOST SCOPE
            if var_name in scope:
                scope_to_update = scope
                break

        # If not found in any scope
        if scope_to_update is NO_VALUE_DEFINED:
            super().error(
                ErrorType.NAME_ERROR,
                f"Variable { {var_name} } not found in any scope"
            )

        var_type = scope_to_update[var_name]['type']

        # Calculate expression
        node_expression = node_dict['expression']
        node_type = node_expression.elem_type

        # If string, int, or boolean value
        if (node_type == 'string' or node_type == 'int' or node_type == 'bool'):
            # Check that type matches
            if (node_type != var_type):
                # Coercion between int --> bool
                if (var_type == 'bool' and node_type == 'int'):
                    int_val = self.get_value(node_expression)
                    scope_to_update[var_name]['val'] = bool(int_val)
                else:
                    super().error(
                        ErrorType.TYPE_ERROR,
                        f"Cannot assign type { { node_type} } to variable \"{var_name}\" of type { {var_type} }"
                    )
            else:
                scope_to_update[var_name]['val'] = self.get_value(node_expression)
            
            if (self.trace_output == True):
                print("\t\tUpdated scope_stack: ", scope_stack)

        # # If another variable
        elif (node_type == 'var'):
            other_var_val = self.get_variable_value(node_expression, scope_stack)
            # print("RETURNED VALUE = ", other_var_val)
            other_var_type = other_var_val['type']
            
            # If trying to assign a variable of a different type --> type error
            if (other_var_type != var_type):
                # Coercion between int --> bool
                if (var_type == 'bool' and other_var_type == 'int'):
                    scope_to_update[var_name]['val'] = bool(other_var_val['val'])
                else:
                    super().error(
                        ErrorType.TYPE_ERROR,
                        f"Cannot assign type of variable  { { other_var_type} } of variable \"{node_expression.dict['name']}\" to variable \"{var_name}\" of type { {var_type} }"
                    )
            else:
                # Otherwise, update w/ new variable value       ( copy for primitives )
                scope_to_update[var_name]['val'] = other_var_val['val']
            
            if (self.trace_output == True):
                print("\t\tUpdated scope_stack: ", scope_stack)

        # Function call
        elif (node_type == 'fcall'):
            fcall_ret = self.run_fcall(node_expression, scope_stack)
            # Check for void function
            if (fcall_ret == None):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign VOID function { {node_expression.dict['name']} } to variable \"{var_name}\""
                )
            if (fcall_ret['type'] != var_type):
                if (var_type == 'bool' and fcall_ret['type'] == 'int'):
                    scope_to_update[var_name]['val'] = bool(fcall_ret['val'])
                else:
                    super().error(
                        ErrorType.TYPE_ERROR,
                        f"Cannot assign fcall return value of type  { { fcall_ret['val']} } to variable \"{var_name}\" of type { {var_type} }"
                    )
            else:
                scope_to_update[var_name]['val'] = fcall_ret['val']
            
            if (self.trace_output == True):
                print("\t\tUpdated scope_stack: ", scope_stack)


        # If not another var or a constant, check all allowable operations for this type
        elif (var_type == 'int'):
            scope_to_update[var_name]['val'] = self.int_types(node_expression, scope_stack)

        elif (var_type == 'bool'):
            scope_to_update[var_name]['val'] = self.bool_types(node_expression, scope_stack)

        elif (var_type == 'string'):
            scope_to_update[var_name]['val'] = self.string_types(node_expression, scope_stack)
        
        # Nil value
        elif (node_type == 'nil'):
            if (var_type not in self.defined_structs):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign non-struct variable \"{var_name}\" to NIL value"
                )
            scope_to_update[var_name]['val'] = Element("nil")
            if (self.trace_output == True):
                print("\t\tUpdated scope_stack: ", scope_stack)
        
        # Instantiating new struct object
        elif (node_type == 'new'):
            struct_OR = self.BrewinStruct(self, node_expression)
            scope_to_update[var_name]['val'] = struct_OR
        else:
            super().error(
                    ErrorType.TYPE_ERROR,
                    f"Unrecognized expression \"{node_type}\" in variable assignment for {var_name}"
                ) 


    ''' ---- If Statement ---- '''
    def check_condition(self, condition, func_vars):
        
        # If constant value
        if (condition.elem_type == 'bool'):
            eval_statements =  self.get_value(condition)
        elif (condition.elem_type == 'int'):
            eval_statements = bool(self.get_value(condition))
        elif (condition.elem_type == 'string' or condition.elem_type == 'nil'):
            super().error(
                ErrorType.TYPE_ERROR,
                f"Cannot evaluate STRING or INT or NIL in 'if' statement condition"
            )
        
        # If variable value
        elif (condition.elem_type == 'var'):
            # Check variable is defined
            val = self.get_variable_value(condition, func_vars)

            if val['type'] == 'bool' or val['type'] == 'int':
                eval_statements = bool(val['val'])
            else:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot evaluate STRING or INT (or nil?) in 'if' statement condition, attempted (via existing variable {condition.dict['name']} value)"
                )

        # If fcall
        elif (condition.elem_type == 'fcall'):
            fcall_return = self.run_fcall(condition, func_vars)
            if (fcall_return is None):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot use VOID function { {condition.dict['name']} } in CONDITION"
                )

            if (fcall_return['type'] == 'bool' or fcall_return['type'] == 'int'):
                eval_statements = bool(fcall_return['val'])
            else:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot evaluate NON-BOOL in 'if' statement condition, attempted via fcall to \" {condition.dict['name']} \""
                )

        elif (condition.elem_type in self.EQUALITY_COMPARISONS):
            eval_statements = self.check_equality(condition, func_vars)
        elif (condition.elem_type in self.INTEGER_COMPARISONS):
            eval_statements = self.integer_compare(condition, func_vars)
        elif (condition.elem_type in self.BOOL_OPERATIONS):
            eval_statements = self.run_bool_operation(condition, func_vars)
        
        # CHECK : IF none of these, is likely an integer expression
        else:
            super().error(
                    ErrorType.TYPE_ERROR,
                    f"Unrecognized expression type { {condition.elem_type} } for 'if' condition: { {condition} }"
                )

        if (eval_statements is not True and eval_statements is not False):
            super().error(
                ErrorType.TYPE_ERROR,
                f"Condition did not evaluate to boolean value { { eval_statements } }"
            )
        return eval_statements

    def evaluate_if(self, node, scope_stack):
        if self.trace_output:
            print("** Inside EVALUATE_IF\tNode: ", node)

        new_scope = {}
        scope_stack.append( new_scope )

        condition = node.dict['condition']
        statements = node.dict['statements']
        else_statements = node.dict['else_statements']

        eval_condition = self.check_condition(condition, scope_stack)

        if (eval_condition):
            # Loop through function statements in order
            for statement_node in statements:
                self.run_statement( statement_node , scope_stack)
        else:
            if else_statements != None:
                for statement_node in else_statements:
                    self.run_statement( statement_node, scope_stack)

        # Pop off new scope's variables
            # yup pop off
        scope_stack.pop()
        
    ''' --- For Loop ---- '''
    def run_for_loop(self, node, scope_stack):
        if self.trace_output:
            print("** Inside RUN FOR LOOP\tNode: ", node)

        initialize = node.dict['init']
        condition = node.dict['condition']
        update = node.dict['update']
        statements = node.dict['statements']

        # Initialize counter variable in variable dictionary
        self.run_assign(initialize, scope_stack)

        # Check condition is true to begin with
        eval_condition = self.check_condition(condition, scope_stack)

        # While condition is true, execute statements
        while (eval_condition):
            # Initialize new scope for this loop iteration
            new_scope = {}
            scope_stack.append( new_scope )


            # Loop through function statements in order
            for statement_node in statements:
                self.run_statement( statement_node , scope_stack)

            # Pop off new scope's variables when done running statements
            scope_stack.pop()

            # Update counter variable value
            self.run_assign(update, scope_stack)

            # Check condition again
            eval_condition = self.check_condition(condition, scope_stack)



    ''' ---- Overloaded Operation ---- '''
    def overloaded_operator(self, node, func_vars):
        if (self.trace_output):
            print("IN OVERLOADED OPERATOR function")

        node_type = node.elem_type
        op1 = node.dict['op1']
        op2 = node.dict['op2']

        # print("\n-- In OVERLOADED OPS\tOp1 = ", op1, "\top2 = ", op2)


        # Get operator values 
        op1_value = self.eval_op(op1, func_vars)
        op2_value = self.eval_op(op2, func_vars)

        # Check that operands are of the same type
        if ( type(op1_value) != type(op2_value)):
            super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use {node_type} on different types { type(op1_value)} and { type(op2_value)}"
            )

        if node_type == '+':
            # '+' is defined for INT and STRING
            if type(op1_value) == int:
                return self.run_int_operation(node, func_vars)
            if type(op1_value) == str:
                return self.run_string_operation(node, func_vars)
            else:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"No {node_type} operation defined for { type(op1_value) }\t(Overloaded Op function)"
                )
    
    ''' ---- Operations Allowed for Specific Types ---- '''
    def int_types(self, node_expression, scope_stack):

        node_type = node_expression.elem_type

        if (node_type == 'int'):
            return self.get_value(node_expression)
        
        elif (node_type == 'var'):
            other_var_val = self.get_variable_value(node_expression, scope_stack)
            other_var_type = other_var_val['type']
            if (other_var_type != 'int'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign type of variable { { other_var_type} } of variable \"{node_expression.dict['name']}\" INT variable  (Inside INT_TYPES)"
                )
            
            return other_var_val['val']
        
        # Integer Operation to be computed
        elif (node_type in self.INT_OPERATIONS):
            return self.run_int_operation(node_expression, scope_stack)

        # Function call
        elif (node_type == 'fcall'):
            fcall_ret = self.run_fcall(node_expression, scope_stack)
            if (fcall_ret is None or fcall_ret['type'] != 'int'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot use FCALL to \"{node_expression.dict['name']} \" w/ return type { { fcall_ret['type'] }} in INT_TYPES"
                )
            return fcall_ret['val']
        
        # This function handles type checking - if the return value is not an integer, throw error
        else:
            super().error(
                ErrorType.TYPE_ERROR,
                f"INSIDE INT_TYPES: Cannot perform non-integer operation { {node_type} } and return int value"
            )


    def bool_types(self, node_expression, scope_stack):
        
        node_type = node_expression.elem_type

        if (node_type == 'bool' or node_type == 'int'):
            return bool(self.get_value(node_expression))
        
        elif (node_type == 'var'):
            other_var_val = self.get_variable_value(node_expression, scope_stack)
            other_var_type = other_var_val['type']
            if (other_var_type != 'bool' and other_var_type != 'int'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign type of variable { { other_var_type} } of variable \"{node_expression.dict['name']}\" BOOL variable  (Inside BOOL_TYPES)"
                )
            
            return bool(other_var_val['val'])

        # Boolean Operation to be computed
        elif (node_type in self.BOOL_OPERATIONS):
            return self.run_bool_operation(node_expression, scope_stack)

        # Equality comparison
        elif (node_type in self.EQUALITY_COMPARISONS):
            return self.check_equality(node_expression, scope_stack)

        # Integer value comparison
        elif (node_type in self.INTEGER_COMPARISONS):
            return self.integer_compare(node_expression, scope_stack)

        # Function call
        elif (node_type == 'fcall'):
            fcall_ret = self.run_fcall(node_expression, scope_stack)
            if fcall_ret is None or (fcall_ret['type'] != 'bool' and fcall_ret['type'] != 'int'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot use FCALL to \"{node_expression.dict['name']} \" w/ return type { { fcall_ret['type'] }} in BOOL_TYPES"
                )
            return bool(fcall_ret['val'])

        # Integer Operation to be computed
        # TODO: Coercion allowed here
        elif (node_type in self.INT_OPERATIONS):
            return_val =  self.run_int_operation(node_expression, scope_stack)
            return bool(return_val)

        else:
            super().error(
                ErrorType.TYPE_ERROR,
                f"INSIDE BOOL_TYPES: Cannot perform non-boolean operation { {node_type} } and return BOOL value"
            )


    def string_types(self, node_expression, scope_stack):
    
        node_type = node_expression.elem_type

        if (node_type == 'string'):
            return self.get_value(node_expression)
        
        elif (node_type == 'var'):
            other_var_val = self.get_variable_value(node_expression, scope_stack)
            other_var_type = other_var_val['type']
            if (other_var_type != 'string'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign type of variable { { other_var_type} } of variable \"{node_expression.dict['name']}\" STRING variable  (Inside STRING_TYPES)"
                )
        
            return other_var_val['val']
        
                # Function call
        elif (node_type == 'fcall'):
            fcall_ret = self.run_fcall(node_expression, scope_stack)
            if (fcall_ret is None or fcall_ret['type'] != 'string'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot use FCALL to \"{node_expression.dict['name']} \" w/ return type { { fcall_ret['type'] }} in STRING_TYPES"
                )
            return fcall_ret['val']
        
        elif (node_type in self.STRING_OPERATIONS):
            return self.run_string_operation(node_expression, scope_stack)
        
        else:
            super().error(
                ErrorType.TYPE_ERROR,
                f"INSIDE STRING_TYPES: Cannot perform non-string operation { {node_type} } and return STRING value"
            )
                

    
    ''' ---- Evaluating Expressions / Operations ---- '''
        # Should return value of operation

    def run_int_operation(self, node, func_vars):
        node_type = node.elem_type

        if node_type == 'string' or node_type == 'bool' or node_type == 'nil':
            super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use string or bool constant in integer operation"
            )
        
        # If int value
        if node_type == 'int':
            return self.get_value(node)
        
        # If variable
        if node_type == 'var':
            node_value = self.get_variable_value(node, func_vars)
            return_node_type = node_value['type']

            # NEW: below line
            node_value = node_value['val']
            # print("\tPassed in variable w/ value: ", node_value)
            if (return_node_type != 'int'):
                super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use string or bool or nil via existing variable {node.dict['name']} in integer operation"
            )
            
            # otherwise, it is an integer value
            return node_value 
        
        if node_type == 'fcall':
            fcall_ret = self.run_fcall(node, func_vars)
            # Check function was not void
            if (fcall_ret is None):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempted to use NONE via fcall to \" {node.dict['name']} \" in INTEGER operation"
                )
            # Check function returned an integer
            if (fcall_ret['type'] != 'int'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempted to use TYPE \"{fcall_ret['type'] }\"  via fcall to \" {node.dict['name']} \" in INTEGER operation"
                )
                
            return fcall_ret['val']

        allowable_types = ['int', 'var', 'fcall'] + self.INT_OPERATIONS
        
        # Unary negation
        if node_type == 'neg':
            op1 = node.dict['op1']
            if op1.elem_type not in allowable_types:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Operand 1 is NOT of an allowable type for integer operation: op1 = {op1}"
                )
            return -( self.run_int_operation( node.dict['op1'], func_vars))
        
        # Operation
        op1 = node.dict['op1']
        op2 = node.dict['op2']

        if op1.elem_type not in allowable_types:
            super().error(
                ErrorType.TYPE_ERROR,
                f"Operand 1 is NOT of an allowable type for integer operation: op1 = {op1}"
            )
        if op2.elem_type not in allowable_types:
            super().error(
                ErrorType.TYPE_ERROR,
                f"Operand 2 is NOT of an allowable type for integer operation: op2 = {op2}"
            )

        if node_type == '+':
            return self.run_int_operation(op1, func_vars) + self.run_int_operation(op2, func_vars)
        if node_type == '-':
            return self.run_int_operation(op1, func_vars) - self.run_int_operation(op2, func_vars)
        if node_type == '*':
            return self.run_int_operation(op1, func_vars) * self.run_int_operation(op2, func_vars)
        if node_type == '/':
            return self.run_int_operation(op1, func_vars) // self.run_int_operation(op2, func_vars)


    def run_string_operation(self, node, func_vars):
        if (self.trace_output == True):
            print("STRING OPERATION: ", node.elem_type)

        node_type = node.elem_type

         # BASE: if operand is a VARIABLE --> return that variable's value
        if node_type == 'var':
            val = self.get_variable_value(node, func_vars)
            val_type = val['type']

            val = val['val']

            # Check if INT or BOOL
            if (val_type != 'string'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Incompatible types for STRING operation, attempted to use INTEGER or BOOL (via existing variable {node.dict['name']} value)"
                )
            # Otherwise, return value
            return val
        
        if node_type == 'bool' or node_type == 'int' or node_type == 'nil':
            super().error(
                    ErrorType.TYPE_ERROR,
                    f"Incompatible types for STRING operation, attempted to use boolean or integer (or nil) constant value"
                )
            
        if node_type == 'string':
            return self.get_value(node)
        
        if node_type == 'fcall':
            fcall_ret = self.run_fcall(node, func_vars)
            # Check function was not void
            if (fcall_ret is None):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempted to use NONE via fcall to \"{node.dict['name']}\" in STRING operation"
                )
            # Check function returned a string
            if (fcall_ret['type'] != 'string'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempted to use TYPE \"{fcall_ret['type'] }\"  via fcall to \" {node.dict['name']} \" in STRING operation"
                )
                
            return fcall_ret['val']

        # String concatenation
        if node_type == '+':
            op1 = node.dict['op1']
            op2 = node.dict['op2']
            return ( self.run_string_operation(op1, func_vars) + self.run_string_operation(op2, func_vars) )


    ''' ---- Calculate BOOLEAN OPERATION ---- '''

    def run_bool_operation(self, node, func_vars):

        node_type = node.elem_type

        if node_type == 'string' or node_type == 'nil':
            super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use int, string, or nil constant in bool operation"
            )
        
        # If already a boolean --> return
        if node_type == 'bool' or node_type == 'int':
            return bool(self.get_value(node))
        
        # If variable
        if node_type == 'var':
            node_value = self.get_variable_value(node, func_vars)
            return_node_type = node_value['type']

            node_value = node_value['val']

            if (return_node_type != 'bool' and return_node_type != 'int'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempted to use int, string, or nil via existing variable {node.dict['name']} in BOOL operation"
                )
            
            # Return variable value
            return bool(node_value)
        
        
        # Function call
        if node_type == 'fcall':
            fcall_ret = self.run_fcall(node, func_vars)
            # Check function was not void
            if (fcall_ret is None):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempted to use NONE via fcall to \"{node.dict['name']}\" in BOOL operation"
                )
            # Check function returned an integer
            if (fcall_ret['type'] != 'bool' and fcall_ret['type'] != 'int'):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempted to use TYPE \"{fcall_ret['type'] }\"  via fcall to \" {node.dict['name']} \" in BOOL operation"
                )
                
            return bool(fcall_ret['val'])
        
        if node_type in self.INT_OPERATIONS:
            return bool(self.run_int_operation(node, func_vars))
        
        allowable_types = ['bool', 'var', 'fcall', 'int'] + self.BOOL_OPERATIONS + self.EQUALITY_COMPARISONS + self.INTEGER_COMPARISONS + self.INT_OPERATIONS
        
        # Unary Boolean NOT
        if node_type == '!':
            op1 = node.dict['op1']
            if op1.elem_type not in allowable_types:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Operand 1 is NOT of an allowable type for BOOL operation: op1 = {op1}"
                )
            return not (self.run_bool_operation( node.dict['op1'], func_vars))
        
        op1 = node.dict['op1']
        op2 = node.dict['op2']

        # If not an allowable boolean operation
        if op1.elem_type not in allowable_types:
            super().error(
                ErrorType.TYPE_ERROR,
                f"Operand 1 is NOT of an allowable type for BOOL operation: op1 = \"{op1}\""
            )
        if op2.elem_type not in allowable_types:
            super().error(
                ErrorType.TYPE_ERROR,
                f"Operand 2 is NOT of an allowable type for BOOL operation: op2 = \"{op2}\""
            )

        # Boolean operation
        if node_type == '||':
            op1_value = self.run_bool_operation(op1, func_vars)
            op2_value = self.run_bool_operation(op2, func_vars)
            return op1_value or op2_value
        
        if node_type == '&&':
            op1_value = self.run_bool_operation(op1, func_vars)
            op2_value = self.run_bool_operation(op2, func_vars)
            return op1_value and op2_value


    ''' ---- Comparison Operations ---- '''
    def eval_op(self, node, func_vars):
            op_type = node.elem_type

            # Get variable value
            if op_type == 'var':
                ret_val = self.get_variable_value(node, func_vars)
                return ret_val['val']

            # If value type
            if op_type == 'int' or op_type == 'string' or op_type == 'bool':
                return self.get_value(node)
            
            if op_type == 'fcall':
                fcall_ret = self.run_fcall(node, func_vars)
                if (fcall_ret is None):
                    return None
                # if decide to return dictionary here, can get type with fcall_ret['type']
                return fcall_ret['val']
            
            if op_type == 'nil':
                return Element("nil")
            
            if op_type in self.OVERLOADED_OPERATIONS:
                return self.overloaded_operator(node, func_vars)
            
            if op_type in self.INT_OPERATIONS:
                return self.run_int_operation(node, func_vars)
            
            if op_type in self.BOOL_OPERATIONS:
                return self.run_bool_operation(node, func_vars)
            
            if op_type in self.EQUALITY_COMPARISONS:
                return self.check_equality(node, func_vars)
            
            if op_type in self.INTEGER_COMPARISONS:
                return self.integer_compare(node, func_vars)

            return NO_VALUE_DEFINED
            

    def check_equality(self, node, func_vars):
        node_type = node.elem_type
        op1 = node.dict['op1']
        op2 = node.dict['op2']

        # Get operator values 
        op1_value = self.eval_op(op1, func_vars)
        op2_value = self.eval_op(op2, func_vars)

        if op1_value is None or op2_value is None:
            super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use NONE in equality comparison"
            )

        same = NO_VALUE_DEFINED

        if (op1_value is NO_VALUE_DEFINED) or (op2_value is NO_VALUE_DEFINED):
            print("** ERR: EVAL_OP did not return anything\n___________________________\n")

        
        # If both are bool
        if ((op1_value is True) and (op2_value is True)) or ( (op1_value is False) and (op2_value is False)):
            same = True
        elif ( (op1_value is True) and (op2_value is False)) or ((op1_value is False) and (op2_value is True)):
            same = False

        op1_type = type(op1_value)
        op2_type = type(op2_value)

        # NIL check - only structs can be compared to nil
        if op1_type == Element and op1_value.elem_type == 'nil':
            if op2_type == Element and op2_value.elem_type == 'nil':
                same = True 
            elif op2_type == self.BrewinStruct:
                same = (op1_value == op2_value)     # Is False
            else:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempt to compare NIL to non-struct element { {op2_value} }"
                )
        elif op2_type == Element and op2_value.elem_type == 'nil':
            # Should already be checked if they're both nil, don't need to check if op1 is nil here
            if op1_type == self.BrewinStruct:
                same = (op2_value == op1_value)
            else:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Attempt to compare NIL to non-struct element { {op1_value} }"
                )

        elif (op1_type != op2_type):
            if (op1_type == bool and op2_type == int) or (op1_type == int and op2_type == bool):
                same = (bool(op1_value) == bool(op2_value))
            else:
                same = False

        else:
            same = (op1_value == op2_value)

        # Actually perform equality check
        if node_type == '==':
            return same
        elif node_type == '!=':
            return not same
        else:
            super().error(
                ErrorType.NAME_ERROR,
                f"Unrecognized equality operation of type {node_type}"
            )


    def integer_compare(self, node, func_vars):
        if (self.trace_output == True):
            print("CHECKING EQUALITY: ", node.elem_type)

        node_type = node.elem_type
        op1 = node.dict['op1']
        op2 = node.dict['op2']

        # Get operator values 
        op1_value = self.run_int_operation(op1, func_vars)
        op2_value = self.run_int_operation(op2, func_vars)

        if op1_value is None or op2_value is None:
            super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use NONE in integer comparison operation"
            )

        # If not integers --> type error
        if ( type(op1_value) != int) or (type(op2_value) != int):
            super().error(
                ErrorType.TYPE_ERROR, 
                f"Can't use operation {node_type} on non-integer values {op1_value} and {op2_value}"
            )

        if node_type == '<':
            return op1_value < op2_value
        if node_type == '<=':
            return op1_value <= op2_value
        if node_type == '>=':
            return op1_value >= op2_value
        if node_type == '>':
            return op1_value > op2_value


    # Return value of value nodes
    def get_value(self, node):
        return node.dict['val']
    

    def get_variable_value(self, node, scope_stack):
        # POSSIBLE PROBLEM CAUSE with structs
        # TODO (structs): might need to return struct_access()['val'] b/c need actual obj ref, not the Object thing that python stores
        
        var_name = node.dict['name']
        # Check for struct access
        if ('.' in var_name):
            return self.struct_access(node, scope_stack)

        else:
            # Otherwise, look at regular variable names
            for scope in scope_stack[::-1]:
                # If variable exists in this scope, this is the value you want to return
                if var_name in scope:
                    return scope[var_name]
        
        # If not found in any scope, error
        super().error(
                ErrorType.NAME_ERROR,
                f"Variable {var_name} has not been declared w/in function scope"
            )
        
    ''' ---- STRUCT PROCESSING  ---- '''
    def struct_access(self, node, scope_stack):

        var_access = node.dict['name']
        parts = var_access.split('.')
        var_name = parts[0]
        temp_variable = Element("var")
        temp_variable.dict['name'] = var_name

        var_value = self.get_variable_value(temp_variable, scope_stack)

        # Check it is a struct
        if (var_value['type'] not in self.defined_structs):
            super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use dot operator on NON-STRUCT variable { {var_name} } of type \"{var_value['type']}\""
            )

        
        struct_object_ref = var_value['val']
        accessing_from = struct_object_ref

        struct_val_dict = {}

        # Loop through dot accesses
            # Left-associative: For each access, get the value stored in that field and use that for the next access
        for field_access in parts[1:]:
            if (type(accessing_from) == Element and accessing_from.elem_type == 'nil'):
                super().error(
                    ErrorType.FAULT_ERROR,
                    f"Attempting to use dot operator on uninitialized struct via field \"{field_access}\""
                )
            struct_val_dict = accessing_from.get_field(field_access)
            returned_value = struct_val_dict['val']
            accessing_from = returned_value

        # print("\n-- Returning from STRUCT ACCESS: ", struct_val_dict)
        return struct_val_dict

    def struct_update(self, node, scope_stack):

        # For scope_stack updating: need actual variable name, not whole string w/ '.'
        var_access = node.dict['name']
        parts = var_access.split('.')
        var_name = parts[0]

        node_dict = node.dict

        scope_to_update = NO_VALUE_DEFINED

        # Traverse stack in reverse order
        for scope in scope_stack[::-1]:
            # If variable exists in this scope, this is the one you want to update
            # ONLY EDIT TOPMOST SCOPE
            if var_name in scope:
                scope_to_update = scope
                break

        # If not found in any scope
        if scope_to_update is NO_VALUE_DEFINED:
            super().error(
                ErrorType.NAME_ERROR,
                f"Variable { {var_name} } not found in any scope"
            )

        if (scope_to_update[var_name]['type'] not in self.defined_structs):
            super().error(
                ErrorType.TYPE_ERROR,
                f"Attempted to use dot operator on NON-STRUCT variable { {var_name} } of type \"{scope_to_update[var_name]['type']}\""
            )

        # Get the actual object dictionary to update
        temp_variable = Element("var")
        temp_variable.dict['name'] = var_access
        variable_dict_to_update = self.struct_access(temp_variable, scope_stack)

        # Calculate expression
        node_expression = node_dict['expression']
        node_type = node_expression.elem_type
        var_type = variable_dict_to_update['type']
        # print("VAR TYPE: ", var_type)

        # print("\n\tPassed in EXPRESSION: ", node_expression)
        
        if (node_type == 'string' or node_type == 'int' or node_type == 'bool'):
            if (node_type != var_type):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign type { { node_type} } to variable \"{var_access}\" of type { {var_type} }"
                )
            # Update actual dictionary entry
            variable_dict_to_update['val'] = self.get_value(node_expression)


        elif node_type == 'var':
            # TODO: different for structs, need to use same object ref
            other_var_val = self.get_variable_value(node_expression, scope_stack)
            other_var_type = other_var_val['type']

            # Check that this variable is of the right type
            if (other_var_type != var_type):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign type of variable  { { other_var_type} } of variable \"{node_expression.dict['name']}\" to variable \"{var_access}\" of type { {var_type} }"
                )

            variable_dict_to_update['val'] = other_var_val['val']

        elif node_type == 'fcall':
            fcall_ret = self.run_fcall(node_expression, scope_stack)
            if (fcall_ret['type'] != var_type):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign fcall return value of type  { { fcall_ret['val']} } to variable \"{var_name}\" of type { {var_type} }"
                )
            
            variable_dict_to_update['val'] = fcall_ret['val']

        # If not another var, constant, or function call - check all allowable operations for this type
        elif (var_type == 'int'):
            variable_dict_to_update['val'] = self.int_types(node_expression, scope_stack)
        
        elif (var_type == 'string'):
            variable_dict_to_update['val'] = self.string_types(node_expression, scope_stack)
        
        elif (var_type == 'bool'):
            variable_dict_to_update['val'] = self.bool_types(node_expression, scope_stack)

        # Nil value
        elif (node_type == 'nil'):
            if (var_type not in self.defined_structs):
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Cannot assign non-struct variable \"{var_name}\" to NIL value"
                )
            variable_dict_to_update['val'] = Element("nil")

        elif (node_type == 'new'):
            struct_OR = self.BrewinStruct(self, node_expression)
            variable_dict_to_update['val'] = struct_OR
        else:
            super().error(
                    ErrorType.TYPE_ERROR,
                    f"Unrecognized expression \"{node_type}\" in variable assignment for {var_access}"
                )
        

    
    ''' ---- INPUTI function ---- '''
    def inputi(self, prompt=[]):
        if (prompt == []):
            user_input = super().get_input()
        else:
            prompt_string = prompt[0].dict['val']
            super().output(prompt_string)
            user_input = super().get_input()

        return int(user_input)

    ''' ---- INPUTIS function ---- '''
    def inputs(self, prompt=[]):
        if (prompt == []):
            user_input = super().get_input()
        else:
            prompt_string = prompt[0].dict['val']
            super().output(prompt_string)
            user_input = super().get_input()

        return str(user_input)

    ''' ---- PRINT function ---- '''
    def printout(self, func_vars, lst=[]):
        if (self.trace_output):
            print("\tINSIDE PRINTOUT")

        # lst = list of strings to concatenate
        string_to_output = ""
        for element in lst:
            if (self.trace_output == True):
                print("\t", element)
            node_type = element.elem_type
            if node_type == 'string':
                string_to_output += element.dict['val']
            elif node_type == 'bool':
                result = element.dict['val']
                if result is True:
                    string_to_output += "true"
                if result is False:
                    string_to_output += "false"
            elif node_type == 'int':
                string_to_output += str(element.dict['val'])
            # # If variable, retrieve variable value
            elif node_type == 'var':
                # will raise error if variable hasn't been defined
                val = self.get_variable_value(element, func_vars)
                val = val['val']
                if val is True:
                    string_to_output += "true"
                elif val is False:
                    string_to_output += "false"
                else:
                    string_to_output += str (val)

            elif (node_type in self.OVERLOADED_OPERATIONS):
                # If BOOLS in overloaded operatos --> need to add the True False check
                string_to_output += str (self.overloaded_operator(element, func_vars))

            elif (node_type in self.INT_OPERATIONS):
                string_to_output += str (self.run_int_operation(element, func_vars))
            
            elif (node_type in self.BOOL_OPERATIONS):
                result = self.run_bool_operation(element, func_vars)
                if result is True:
                    string_to_output += "true"
                if result is False:
                    string_to_output += "false"

            elif (node_type in self.EQUALITY_COMPARISONS):
                result = self.check_equality(element, func_vars)
                if result is True:
                    string_to_output += "true"
                if result is False:
                    string_to_output += "false"

            elif (node_type in self.INTEGER_COMPARISONS):
                result = self.integer_compare(element, func_vars)
                if result is True:
                    string_to_output += "true"
                if result is False:
                    string_to_output += "false"

            elif node_type == 'fcall':
                fcall_ret = self.run_fcall(element, func_vars)
                fcall_ret_val = fcall_ret['val']
                if fcall_ret['type'] == 'bool':
                    if fcall_ret_val is True:
                        string_to_output += "true"
                    if fcall_ret_val is False:
                        string_to_output += "false"
                else:
                    string_to_output += str(fcall_ret_val)

        super().output(string_to_output)