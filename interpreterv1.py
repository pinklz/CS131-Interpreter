from brewparse import parse_program
from intbase import *

class Interpreter(InterpreterBase):
    program_vars = {}
   
    def __init__(self, console_output=True, inp=None, trace_output=False):
        super().__init__(console_output, inp)   # call InterpreterBase's constructor

    ''' ---- RUN PROGRAM ---- '''
    def run(self, program):
        ''' 
            program = array of strings containing program
            ast = AST generated by parser
            self.program_vars = map to hold variables + their values
        '''
        self.ast = parse_program(program)
        self.program_vars = {}

        ''' ---- Find Main Node ---- '''
        # Check program validity
        if (self.ast.elem_type != 'program'):
            super().error(
                ErrorType.NAME_ERROR,
                "Initial element type is not 'program' "
            )
        
        # Search through program functions to find the MAIN node
        main_node = None
        for func in self.ast.dict['functions']:
            if (func.dict['name'] == 'main'):
                main_node = func
        if (main_node == None):
            super().error(
                ErrorType.NAME_ERROR,
                "No MAIN node found in program"
            )
        
        # Run MAIN node
        self.run_func(main_node)


    ''' ---- RUN FUNCTION ---- '''
    def run_func(self, func_node):
        if (func_node.elem_type != 'func'):
            super().error(
                ErrorType.TYPE_ERROR,
                "Non-function node passed into run_func"
            )

        
        node_dict = func_node.dict
        print("\n-- Currently running function: ", node_dict['name'])

        ''' ---- Run statements in order ---- '''
        for statement_node in node_dict['statements']:
            self.run_statement( statement_node )
    

    ''' ---- RUN STATEMENT ---- '''
    def run_statement(self, statement_node):
        node_type = statement_node.elem_type

        # Run node's respective function
        match node_type:
            case 'vardef':
                print("\nRUN_STATEMENT: This node is a variable definition")
                self.run_vardef(statement_node)
            case '=':
                print("\nRUN_STATEMENT: This node is a variable assignment")
                self.run_assign(statement_node)
            case 'fcall':
                print("\nRUN_STATEMENT: This node is a function call")
                self.run_fcall(statement_node)
            case _:
                super().error(
                    ErrorType.NAME_ERROR,
                    f"Unrecognized statement of type {node_type}"
                )


    ''' *** Running Statement Types *** '''
    # VARDEF
    def run_vardef(self, node):
        print("\tInside RUN_VARDEF")
        var_name = node.dict['name']

        # Check if variable has already been defined
        if var_name in self.program_vars:
            super().error(
                ErrorType.NAME_ERROR,
                f"Variable {var_name} defined more than once"
            )

        
        # Add new variable to PROGRAM_VARS           Initial value: None
        self.program_vars[var_name] = None
        print("\t\tCurrent program_vars: ", self.program_vars)

    # VARIABLE ASSIGNMENT
    def run_assign(self, node):
        print("\tInside RUN_ASSIGN")
        node_dict = node.dict
        var_name = node_dict['name']

        # Check that variable has been declared
        if var_name not in self.program_vars:
            super().error(
                ErrorType.NAME_ERROR,
                f"Variable {var_name} has not been declared"
            )


        # Calculate expression
        ''' you must evaluate the expression/variable/value to the right of the equal sign
        and then assiciate the variable name on the left of the equal sign with that resulting value
        
        when set y = x --> y points to the var node x (not the value)
        '''
        node_expression = node_dict['expression']
        # TODO: Check ALL of: expression, value, or variable

        match node_expression.elem_type:
            # If VALUE type
            # case 'int':
            #     self.program_vars[var_name] = self.get_value(node_expression)
            #     print("\t\tUpdated program_vars: ", self.program_vars)
            case 'string':
                self.program_vars[var_name] = self.get_value(node_expression)
                print("\t\tUpdated program_vars: ", self.program_vars)
            
            # If EXPRESSION type
            case 'int':
                self.program_vars[var_name] = self.run_operation(node_expression)
                print("\t\tUpdated program_vars: ", self.program_vars)
            case '+':
                self.program_vars[var_name] = self.run_operation(node_expression)
                print("\t\tUpdated program_vars: ", self.program_vars)

            # If FUNCTION CALL type
            case 'fcall':
                print("++ Functioncall, not here yet")

            case _:
                super().error(
                    ErrorType.TYPE_ERROR,
                    f"Unrecognized expression {node_expression.elem_type} in variable assignment for {var_name}"
                )

        # Update program_vars w/ new value TODO TODO for expressions + function calls

    # FUNCTION CALL
    def run_fcall(self, node):
        print("\tInside RUN_FCALL")


    # OPERATION NODE
        # Should return value of operation
        # If nested, call run_op on the nested one --> should return value of nested operation to be used in top level op
    def run_operation(self, node):
        print("OPERATION: ", node.elem_type)

        node_type = node.elem_type

         # BASE: if operand is a VARIABLE --> return that variable's value
        if node_type == 'var':
            if node.dict['name'] not in self.program_vars:
                super().error(
                    ErrorType.NAME_ERROR,
                    f"Variable {node.dict['name']} has not been declared"
                )
            # TODO: make sure variable value is not a string
            return self.program_vars[ node.dict['name'] ]

        # BASE: if operand is a VALUE --> return that value
        if node_type == 'int':
            return self.get_value(node)
        
        if node_type == 'string':
            super().error(
                ErrorType.TYPE_ERROR,
                "Incompatible types for arithmetic operation, attempted to use string"
            )

        # Try operation types
        if node_type == '+':
            op1 = node.dict['op1']
            op2 = node.dict['op2']
            return self.run_operation(op1) + self.run_operation(op2)
        if node_type == '-':
            op1 = node.dict['op1']
            op2 = node.dict['op2']
            return self.run_operation(op1) - self.run_operation(op2)        


    # Return value of value nodes
    def get_value(self, node):
        return node.dict['val']